var us_shp = ee.FeatureCollection("projects/ee-phenology-last/assets/US_SHP");       //你的研究区，研究区过大需要对研究区分块处理
var extract_band = 'EVI';                //Vegetation index used to extract phenology
// var extract_band = 'NIRv';
// var extract_band = 'NDVI';
// var extract_band = 'kNDVI';
var th = 0.5;                            //Threshold for extracting phenology  
var scale = 10;                          //the scale of image
var year = 2019;                         //The year in which phenology is extracted
var start_date = ee.Date((year)+'-01-01');
var end_date = ee.Date((year)+'-12-31');
Map.setOptions('satellite')
//******************************************************Import related library********************************************
var oeel = require('users/OEEL/lib:loadAll');
var palettes = require('users/gena/packages:palettes');    
//****************************************************************c_BRDF parameter*****************************************************************
var left_up = 0;      //左上角坐标索引
var right_up = 1;     //左下角坐标索引
var right_low = 2;    //右下角坐标索引
var left_low = 3;    //右上角坐标索引
var MAX_DISTANCE = 1000000;
var MAX_SATELLITE_ZENITH = 7.5;
var PI = ee.Number(Math.PI);
var dem = ee.Image("USGS/SRTMGL1_003")         //dem data
// Map.addLayer(dem.clip(ROI), {min: 0, max: 5000}, 'dem');
Map.setOptions('satellite')
//*******************************************************
var ESA  = ee.ImageCollection("ESA/WorldCover/v100")
var imageVisParam_ESA = {"opacity":1,"bands":["Map"],"min":10,"max":110,"palette":["#006400","#ffbb22","#ffff4c","#f096ff","#fa0000","#b4b4b4",'#f0f0f0','#0FC9F6','#0096a0','#00cf75','#fae6a0']};
// var ESA_ROI_landcover=ESA
//               .filterBounds(ROI)        //根据研究区过滤影像
//               .mosaic()                  //融合
//               .clip(ROI)                //裁剪
// var esa_mask = ESA_ROI_landcover.neq(80);

var s2_propetry = ee.List(['MEAN_SOLAR_ZENITH_ANGLE','MEAN_SOLAR_AZIMUTH_ANGLE','MEAN_INCIDENCE_ZENITH_ANGLE_B2','MEAN_INCIDENCE_AZIMUTH_ANGLE_B2',
                          'MEAN_INCIDENCE_ZENITH_ANGLE_B3','MEAN_INCIDENCE_AZIMUTH_ANGLE_B3','MEAN_INCIDENCE_ZENITH_ANGLE_B4','MEAN_INCIDENCE_AZIMUTH_ANGLE_B4',
                          'MEAN_INCIDENCE_ZENITH_ANGLE_B8','MEAN_INCIDENCE_AZIMUTH_ANGLE_B8','MEAN_INCIDENCE_ZENITH_ANGLE_B11','MEAN_INCIDENCE_AZIMUTH_ANGLE_B11',
                          'system:time_start','CLOUDY_PIXEL_PERCENTAGE'])
var l8_propetry =  ee.List(['SUN_ELEVATION','SUN_AZIMUTH','system:time_start','footprint','CLOUD_COVER'])
var l8_inBands = ee.List(['SR_B2','SR_B3','SR_B4','SR_B5','SR_B6','QA_PIXEL'])
var s2_inBands = ee.List(['B2','B3','B4','B8','B11'])
var outBands = ee.List(['blue','green','red','nir','swir']); 
var l8_outBands = ee.List(['blue','green','red','nir','swir','QA_PIXEL']);
var landsat_8 = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2");
var sentinel_2 = ee.ImageCollection('COPERNICUS/S2_SR');
print('us_roi',us_shp.size())
var roi_list = us_shp.toList(us_shp.size())

for(var i=0;i<100;i++){
  var ROI =  ee.Feature(roi_list.get(i)).geometry() 
  var point = ROI.centroid()
  var ESA  = ee.ImageCollection("ESA/WorldCover/v100")
  var imageVisParam_ESA = {"opacity":1,"bands":["Map"],"min":10,"max":110,"palette":["#006400","#ffbb22","#ffff4c","#f096ff","#fa0000","#b4b4b4",'#f0f0f0','#0FC9F6','#0096a0','#00cf75','#fae6a0']};
  var ESA_ROI_landcover=ESA
              .filterBounds(ROI)        //根据研究区过滤影像
              .mosaic()                  //融合
              .clip(ROI)                //裁剪
var esa_mask = ESA_ROI_landcover.neq(80).and(ESA_ROI_landcover.neq(60)).and(ESA_ROI_landcover.neq(50))  //mask the water bulid and bare.

var l8_sr = landsat_8.filterDate(ee.Date(start_date).advance(-1,'month'),ee.Date(end_date).advance(1,'month'))          //startDate
                     .filterBounds(ROI)
                     .filter(ee.Filter.lt('CLOUD_COVER',60))
                     .select(l8_inBands,l8_outBands)
                     .map(function(img){
                       var footprint = ee.List(img.geometry().bounds().coordinates().get(0))
                       return img.clip(ROI)
                                 .set('footprint',footprint)
                                // .copyProperties(img, l8_propetry);
                     })       

var s2_sr = sentinel_2.filterDate(ee.Date(start_date).advance(-1,'month'),ee.Date(end_date).advance(1,'month'))          //startDate
                      .filterBounds(ROI)
                      .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE',60))
                      .map(function(img){
                return img.clip(ROI)
                          .copyProperties(img, s2_propetry);
              })
//***********************************************************************去云雪等无效值************************************************************************************
var s2_cloundfree = oeel.Algorithms.Sentinel2.cloudfree(50, s2_sr).map(function(img){     //去云需要近红外波段，所以在这个操作之前不能修改B8A的名称
  var snowmask = img.select(['SCL']).neq(11)      //snow is 0
  return img.updateMask(snowmask)//mask snow
            .divide(10000)       
            .copyProperties(img,s2_propetry);
}).select(s2_inBands,outBands); //像素有50%的可能是云，则去除掉

var l8_cloundfree = l8_sr.map(maskL8sr).map(function(img){return img.multiply(0.0000275).add(-0.2).copyProperties(img,l8_propetry);});
l8_sr = null;
s2_sr = null;
//******************************************************************************同天合成****************************************************************************************
var l8_mos = mosaicByDate(l8_cloundfree).sort('system:time_start');
var s2_mos = mosaicByDate(s2_cloundfree).sort('system:time_start');
l8_cloundfree = null;
s2_cloundfree = null;
//*******************************************************************************影像重采样*********************************************************************************************
l8_mos  = l8_mos.map(function(img){
  return img.reproject('EPSG:4326',null,scale).resample()
            .set('doy',ee.Number(img.date().getRelative('day','year')).add(1))  //函数获取的1月1日是第0天，所以加上1
            .set('crs',img.projection().crs())
            .updateMask(esa_mask)
})
s2_mos  = s2_mos.map(function(img){
  return img.reproject('EPSG:4326',null,scale).resample()
            .set('doy',ee.Number(img.date().getRelative('day','year')).add(1))
            .set('crs',img.projection().crs())
            .updateMask(esa_mask)
})
//*******************************************************************************空值填补***************************************************************************************************
var l8_join = inter_cloud1(l8_mos,30)
var s2_join = inter_cloud1(s2_mos,15)
var l8_inter = ee.ImageCollection(l8_join.map(inter_cloud2)).filterDate(start_date,end_date) 
var s2_inter = ee.ImageCollection(s2_join.map(inter_cloud2)).filterDate(start_date,end_date)
var half = ee.Number(365).divide(s2_inter.size()).round().multiply(6)
var diff = half.multiply(1000*3600*24)
l8_mos,l8_join,s2_mos,s2_join = null,null,null,null;
//*********************************************************************C_BRDF**************************************************************************
var l8_c = l8_inter.map(apply_brdf)            //c adjust
var s2_c = s2_inter.map(apply_brdf_s2)
//**********************************************************************Topography***********************************************************************
l8_c = l8_c.map(function(img){
  return img.set('MEAN_SOLAR_ZENITH_ANGLE',ee.Number(90).subtract(ee.Number(img.get('SUN_ELEVATION'))))
            .set('MEAN_SOLAR_AZIMUTH_ANGLE',ee.Number(img.get('SUN_AZIMUTH')));
})
var l8_ic = l8_c.map(calculate_IC);
var l8_topo = l8_ic.map(topo_SCSc);
var s2_ic = s2_c.map(calculate_IC);
var s2_topo = s2_ic.map(topo_SCSc)
// l8_inter,s2_inter,l8_ic,s2_ic= null,null,null,null;
//***********************************************************************去除遗漏的异常值**************************************************************************
l8_topo = l8_topo.map(sensor_tran);         // adjust bandwidth
var l8_vi = l8_topo.map(get_vi).map(function(img){return img.set('date',ee.Date(img.get('system:time_start')).format('yyyy-MM-dd'))})
var s2_vi = s2_topo.map(get_vi).map(function(img){return img.set('CLOUD_COVER',img.get('CLOUDY_PIXEL_PERCENTAGE')).set('date',ee.Date(img.get('system:time_start')).format('yyyy-MM-dd'))})
var merge_vi =l8_vi.merge(s2_vi).sort('system:time_start')
var snow_ = merge_vi.reduce(ee.Reducer.percentile([5])).clip(ROI)
merge_vi = merge_vi.sort('system:time_start').map(function(img){
  var image = ee.Algorithms.If(ee.Number(img.get('doy')).gt(60).and(ee.Number(img.get('doy')).lt(320)),img ,img.unmask(snow_))
  return image
  })
var smooth_vi = move_window(merge_vi,15).select(['NDVI_mean','EVI_mean','NIRv_mean','kNDVI_mean'],['NDVI','EVI','NIRv','kNDVI']).sort('system:time_start');                                            
var size = merge_vi.size()
var list = ee.List.sequence(0,size.subtract(1))
var ori_list = merge_vi.toList(size)
var smooth_list = smooth_vi.toList(size)
// var text_smooth = ee.ImageCollection.fromImages(smooth_list).sort('system:time_start')
// var ori = list.map(function(i){
//   var ori_vi = ee.Image(ori_list.get(i))
//   var smo_vi = ee.Image(smooth_list.get(i))
//   var vi = ee.ImageCollection([smo_vi,ori_vi]).mosaic()
//   return vi
// })
var res_list = list.map(function(i){
  var res = ee.Image(ori_list.get(i)).subtract(ee.Image(smooth_list.get(i)))
  return res
})
var residual = ee.ImageCollection(res_list)
var vi_sd = residual.reduce(ee.Reducer.stdDev())
var sd_throld = vi_sd.multiply(1.5).abs()
var vi_list = list.map(function(i){
  var res = ee.Image(res_list.get(i)).abs()
  var ori = ee.Image(ori_list.get(i))
  var smooth = ee.Image(smooth_list.get(i))
  var mask = res.lt(sd_throld)
  var vi = ori.updateMask(mask).unmask(smooth)
  return vi
})
var vi_col = ee.ImageCollection.fromImages(vi_list)
                .map(function(img){ 
               var image = ee.Algorithms.If(ee.Number(img.get('doy')).gt(60).and(ee.Number(img.get('doy')).lt(320)),img ,img.unmask(snow_))//.unmask(snow_))
               return image })  

//******************************************************************************SG--Smooth****************************************************************************************
var inputDictionary = {
  
  "collection": vi_col, // 用于计算邻域的图像集合
  "distanceFunction": function(infromedImage,estimationImage){
        return ee.Image.constant(ee.Number(infromedImage.get('system:time_start'))//@ filter：滑动窗口大小
          .subtract(ee.Number(estimationImage.get('system:time_start'))));},
  "degree": 4, // 多项式的次数
  "bandOfInterest": [extract_band], // 需要处理的波段
  "filter": ee.Filter.maxDifference(diff, 'system:time_start', null, 'system:time_start') // 过滤器
};
var merge_sg = sg(inputDictionary).map(function(img){
    var smooth = img.select(ee.String('d_0_').cat(extract_band)).rename(ee.String('sg_').cat(extract_band));       //对平滑后的波段进行重命名
    // var daoshu = img.select(ee.String('d_1_').cat(bandname)).rename(ee.String('f1_').cat(bandname)).multiply(2000000000);
    return img.select(extract_band).addBands([smooth]).updateMask(smooth.lt(0.9).and(smooth.gt(0)))                                     //把重命名的新波段添加到影像中
  }) 
var inter_vi = cubicInterpolation(merge_sg,1)         //插值每天的影像

//********************************************************************************extract phenology*********************************************************************************
var init = ee.Image(ee.Date((year-1)+'-12-31').millis());
var phenology_thr = extract_pheno_thresh(inter_vi,0.5,'sg_'+extract_band)
exportImage_ToAs(phenology_thr.select([0,1]),ROI,'usa_evi_'+i)
}

//***********************************************************************所需函数*****************************************************************************
function maskL8sr(image) {
  // 包括云周边、卷云、云、云阴影和雪，在产品介绍中有说明，可以根据具体的产品改写
  var DilatedCloudBitMask = 1 << 1;    //扩张的云
  var cirrusBitMask = 1 << 2;         //卷云
  var cloudBitMask = 1 << 3;          //云
  var cloudshadowMask = 1<<4;         //云阴影
  var SowBitMask = 1 << 5;            //雪
  
  var qa = image.select('QA_PIXEL');    //generated from the CFMASK algorithm.	
  
  var mask = qa.bitwiseAnd(DilatedCloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0))
      .and(qa.bitwiseAnd(cloudBitMask).eq(0))
      .and(qa.bitwiseAnd(cloudshadowMask).eq(0))
      .and(qa.bitwiseAnd(SowBitMask).eq(0));
 
   return image.updateMask(mask)
          .copyProperties(image,l8_propetry);
}
function mosaicByDate(imcol){
  // convert the ImageCollection into List
  var imlist = imcol.toList(imcol.size());

  // Obtain the distinct image dates from the ImageCollection
  var unique_dates = imlist.map(function(im){
    return ee.Image(im).date().format("YYYY-MM-dd");
  }).distinct();     //返回没有重复日期的list
  // mosaic the images acquired on the same date
  var mosaic_imlist = unique_dates.map(function(d){
    d = ee.Date(d);
    //print(d)
    var im_pro = imcol.filterDate(d, d.advance(1, "day")).first()
    
    var im = imcol.filterDate(d, d.advance(1, "day")).mosaic();
    // var id = imcol.filterDate(d, d.advance(1, "day")).first().id()

    // return the mosaiced same-date images and set the time properties
    return im.set(
      "system:time_start", d.millis(),     //.updateMask(esa_mask)
      "system:id", d.format("YYYY-MM-dd"),
      'doy',d.getRelative("day", "year")
      
      ).copyProperties(im_pro, im_pro.propertyNames())//.updateMask(esa_mask);
  });
  return ee.ImageCollection(mosaic_imlist);
  
}
function inter_cloud1(imcol,interval){            //此函数用来准备稍后插值所要用到的所有影像
  var imcol = imcol.map(function(image) {
  var timeImage = image.metadata('system:time_start','timestamp')//.rename('timestamp')   //使用'system:time_start'创建一个常值图像，波段名字命名为'timestamp'
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))  //select(0),选择图像的第一个波段，目的是使这个常值图像有和输入的卫星影像有相同的掩膜
  return image.addBands(timeImageMasked)    //那这个图像作为波段添加到原图像中
  })
  var days = interval;
  var millis = ee.Number(days).multiply(1000*60*60*24)  //间隔时间的毫秒数
  var maxDiffFilter = ee.Filter.maxDifference({     //一个时间差的过滤条件
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
  })
  // We need a lessThanOrEquals filter to find all images after a given image
  // This will compare the given image's timestamp against other images' timestamps
  var lessEqFilter = ee.Filter.lessThanOrEquals({    //在这个图像之前规定时间差的所有影像
  leftField: 'system:time_start',
  rightField: 'system:time_start'
  })

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
  var greaterEqFilter = ee.Filter.greaterThanOrEquals({    //在这个图像之后规定时间差的所有影像
  leftField: 'system:time_start',
  rightField: 'system:time_start'
  })

  // Apply the joins
  
  // For the first join, we need to match all images that are after the given image.
  // To do this we need to match 2 conditions
  // 1. The resulting images must be within the specified time-window of target image
  // 2. The target image's timestamp must be lesser than the timestamp of resulting images
  // Combine two filters to match both these conditions
  var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)   //将两个过滤条件合到一起
  // This join will find all images after, sorted in descending order
  // This will gives us images so that closest is last
  var join1 = ee.Join.saveAll({     //定义一个连接器
    matchesKey: 'after',            //结果的属性名为after
    ordering: 'system:time_start',  //用来排序的字段名
    ascending: false      //降序排列，使得system:time_start最大的排在影像集的最上面，这样进行mosaic时，离填补影像时间最近的影像会被使用
  })
    
  var join1Result = join1.apply({  //应用之前定义的连接器，符合条件的右侧影像会被当做属性添加到左侧影像中
    primary: imcol,
    secondary: imcol,            //左右都是输入影像
    condition: filter1
  })
  // Each image now as a property called 'after' containing
  // all images that come after it within the time-window
  // print(join1Result.first())
  
  // Do the second join now to match all images within the time-window
  // that come before each image
  var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)     //将两个过滤条件合到一起
  // This join will find all images before, sorted in ascending order
  // This will gives us images so that closest is last
  var join2 = ee.Join.saveAll({    //定义一个连接器  
    matchesKey: 'before',          //结果的属性名为before
    ordering: 'system:time_start', //用来排序的字段名
    ascending: true                //升序排列，使得system:time_start最小的排在影像集的最上面，这样进行mosaic时，离填补影像时间最近的影像会被使用
  })       
    
  var join2Result = join2.apply({   //应用之前定义的连接器，符合条件的右侧影像会被当做属性添加到左侧影像中
    primary: join1Result,           
    secondary: join1Result,         //左右都是第一次应用连接器后的结果影像集
    condition: filter2
  })
  
  // Each image now as a property called 'before' containing
  // all images that come after it within the time-window
  // print(join2Result.first())

  return join2Result                //返回应用连接器后的影像集，此影像集具有before和after两个属性，分别是离此影像时间定义时间差之前和之后所有影像

}
function inter_cloud2(image){             //此函数用来进行线性插值填补
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))     //获取影像时间前的所有影像，使其变为列表形式
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()    //将列表变为影像集，然后进行镶嵌，影像集中最上面的可用元素会被用来生成最终的影像
  var afterImages = ee.List(image.get('after'))      //获取影像时间后的所有影像，使其变为列表形式
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()      //将列表变为影像集，然后进行镶嵌，影像集中最上面的可用元素会被用来生成最终的影像

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')      //选择之前生成的代表影响获取时间的波段，并将其命名为t1
                                                              //输入影像是合成影像，所以，每个像素的时间是该像素所用影像的时间
  var t2 = afterMosaic.select('timestamp').rename('t2')       //选择之前生成的代表影响获取时间的波段，并将其命名为t2

  var t = image.metadata('system:time_start','t')             //获取填补影像的时间将其生成为影像，并将其命名为t ，常值影像 

  var timeImage = ee.Image.cat([t1, t2, t])                       ////将三张代表时间的影像融合为一个多波段影像

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {    //  权重因子ratio，before+(after-before)*ratio,离影像时间越近该权重越小
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))           //进行线性插值
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)//填补去云后的空缺
  var img_pro = image.propertyNames()
  return result.copyProperties(image, img_pro)                 //给结果影像添加时间属性
}
function apply_brdf(img){
   
    var footprint = ee.List(img.get('footprint'));
    
    var sunAz = img.metadata('SUN_AZIMUTH','sunAz').multiply(PI).divide(180)
    var sZenith = ee.Image.constant(ee.Number(90).subtract(ee.Number(img.get('SUN_ELEVATION'))).multiply(PI).divide(180)).rename('sunZen');
  
    var viewAz = azimuth(footprint);
    var viewZen = 0//zenith(footprint);              //计算的c因子差距不大，在千分位
  
    var kval = _kvol(sunAz, sZenith, viewAz, viewZen);
    var kvol = kval[0];
    var kgeo = kval[1];
    var kval_up = _kvol(sunAz,PI.divide(6),viewAz,0)
    var kvol_up = kval_up[0];
    var kgeo_up = kval_up[1];

    var result = _apply(img, kvol, kgeo,kvol_up,kgeo_up);
  
    return result;
}                  //应用brdf校正
function azimuth(footprint){

    function x(point){return ee.Number(ee.List(point).get(0))}
    function y(point){return ee.Number(ee.List(point).get(1))}
    
      var upperCenter = line_from_coords(footprint, left_up, right_up).centroid().coordinates();
      var lowerCenter = line_from_coords(footprint, left_low, right_low).centroid().coordinates();
      var slope = ((y(lowerCenter)).subtract(y(upperCenter))).divide((x(lowerCenter)).subtract(x(upperCenter)));
      var slopePerp = ee.Number(-1).divide(slope);
      var azimuthLeft = ee.Image(PI.divide(2).subtract((slopePerp).atan()));
      return azimuthLeft.rename(['viewAz']);
  }               //计算视场方位角
function zenith(footprint){
      var leftLine = line_from_coords(footprint, left_up, left_low);
      var rightLine = line_from_coords(footprint, right_up, right_low);
      var leftDistance = ee.FeatureCollection(leftLine).distance(MAX_DISTANCE);
      var rightDistance = ee.FeatureCollection(rightLine).distance(MAX_DISTANCE);
      var viewZenith = rightDistance.multiply(ee.Number(MAX_SATELLITE_ZENITH * 2)) 
          .divide(rightDistance.add(leftDistance)) 
          .subtract(ee.Number(MAX_SATELLITE_ZENITH)) 
          .clip(ee.Geometry.Polygon(footprint)) 
          .rename(['viewZen']);
    return viewZenith.multiply(PI.divide(180));
  }                 //计算视场天顶角，可以近似看成0
function _apply(image, kvol, kgeo,kvol_up,kgeo_up){
      var f_iso = 0;
      var f_geo = 0;
      var f_vol = 0;
			var blue = _correct_band(image, 'blue', kvol, kgeo, f_iso=0.0774, f_geo=0.0079, f_vol=0.0372,kvol_up,kgeo_up);
			var green = _correct_band(image, 'green', kvol, kgeo, f_iso=0.1306, f_geo=0.0178, f_vol=0.0580,kvol_up,kgeo_up);
			var red = _correct_band(image, 'red', kvol, kgeo, f_iso=0.1690, f_geo=0.0227, f_vol=0.0574,kvol_up,kgeo_up);
		// 	var re1 = _correct_band(image, 're1', kvol, kgeo, f_iso=0.2085, f_geo=0.0256, f_vol=0.0845);
		// 	var re2 = _correct_band(image, 're2', kvol, kgeo, f_iso=0.2316, f_geo=0.0273, f_vol=0.1003);
		// 	var re3 = _correct_band(image, 're3', kvol, kgeo, f_iso=0.2599, f_geo=0.0294, f_vol=0.1197);
      var nir = _correct_band(image, 'nir', kvol, kgeo, f_iso=0.3093, f_geo=0.0330, f_vol=0.1535,kvol_up,kgeo_up);
      // var re4 = _correct_band(image, 're4', kvol, kgeo, f_iso=0.2907, f_geo=0.0410, f_vol=0.1611);
      var swir = _correct_band(image, 'swir', kvol, kgeo, f_iso=0.3430, f_geo=0.0453, f_vol=0.1154,kvol_up,kgeo_up);   
      // var swir2 = _correct_band(image, 'swir2', kvol, kgeo, f_iso=0.2658, f_geo=0.0387, f_vol=0.0639);
			return image.select([]).addBands([blue, green, red, nir,swir]).set('blue_c',blue.get('c'))
			                                                              .set('green_c',green.get('c'))
			                                                              .set('red_c',red.get('c'))
			                                                              .set('nir_c',nir.get('c'))
			                                                              .set('swir_c',swir.get('c'));
}        //输入modis校正系数
function _correct_band(image, band_name, kvol, kgeo, f_iso, f_geo, f_vol,kvol_up,kgeo_up){
			//"""fiso + fvol * kvol + fgeo * kgeo"""
			var iso = ee.Image(f_iso);
			var geo = ee.Image(f_geo);
			var vol = ee.Image(f_vol);
			var pred = vol.multiply(kvol).add(geo.multiply(kgeo)).add(iso).rename(['pred']);
			var pred_up = vol.multiply(kvol_up).add(geo.multiply(kgeo_up)).add(iso).rename(['pred_up']);
			var cfac = pred_up.divide(pred).rename(['cfac']);             //计算c因子
			var c = cfac.reduceRegion({
                  reducer: ee.Reducer.first(),
                  geometry:point,
                  scale: scale,
                  maxPixels: 1e13
                });
			var corr = image.select(band_name).multiply(cfac).rename([band_name]).set('c',ee.Number(c.get('cfac')));
			return corr;
  }   //进行校正
function _kvol(sAzimuth, sZenith, vAzimuth, vZenith){
			//"""Calculate kvol kernel.
			//From Lucht et al. 2000
			//Phase angle = cos(solar zenith) cos(view zenith) + sin(solar zenith) sin(view zenith) cos(relative azimuth)"""
			sAzimuth = ee.Image(sAzimuth)
			sZenith = ee.Image(sZenith)
			vAzimuth = ee.Image(vAzimuth)
			vZenith = ee.Image(vZenith)
			var rAzimuth = sAzimuth.subtract(vAzimuth).rename(['relAz']);
			var pa1 = vZenith.cos().multiply(sZenith.cos());
			var pa2 = vZenith.sin().multiply(sZenith.sin()).multiply(rAzimuth.cos());
			var phase_angle1 = pa1.add(pa2);
			var phase_angle = phase_angle1.acos();
			var p1 = ee.Image(PI.divide(2)).subtract(phase_angle);
			var p2 = p1.multiply(phase_angle1);
			var p3 = p2.add(phase_angle.sin());
			var p4 = sZenith.cos().add(vZenith.cos());
			var p5 = ee.Image(PI.divide(4));

			var kvol = p3.divide(p4).subtract(p5).rename(['kvol']);     //Ross_thick


      var t1 = sZenith.tan()
	    var ttt1 = t1;
	   // ttt1 = ee.Algorithms.If(ee.Number(t1).lte(0),0,ttt1)
	   // ttt1 = ee.Algorithms.If(ee.Number(t1).gt(0),t1,ttt1)
	    var ttt1 = ee.Image(ttt1).where(ttt1.lt(0),0)
	    var theta_ip = ttt1.atan()
      var t2 = vZenith.tan()
	    var ttt2 = t2;
	   // ttt2 = ee.Algorithms.If(ee.Number(t2).lt(0),0,ttt2)
	   // ttt2 = ee.Algorithms.If(ee.Number(t2).gte(0),t2,ttt2)
	    ttt2 = ee.Image(ttt2).where(ttt2.lt(0),0)
      var theta_vp = ttt2.atan()
	    var temp1 = theta_ip.cos()
	    var temp2 = theta_vp.cos()
	    var cosxip = temp1.multiply(temp2).add(theta_ip.sin().multiply(theta_vp.sin()).multiply(rAzimuth.cos()))
	    var D1 = t1.multiply(t1).add(t2.multiply(t2)).subtract(t1.multiply(t2).multiply(rAzimuth.cos().multiply(ee.Image(2))))
	   // D1 = ee.Algorithms.If(ee.Number(D1).lt(0),0,D1)
	    D1 = ee.Image(D1).where(D1.lt(0),0)
      var D = D1.sqrt()
      var cost1 = t1.multiply(t2).multiply(rAzimuth.sin())
      var cost2 = D1.add(cost1.multiply(cost1))
      var temp3 = ee.Image(1).divide(temp1).add(ee.Image(1).divide(temp2))
      var cost = (cost2.sqrt().divide(temp3)).multiply(2)
	    var costttt1 = cost;
      // costttt1 = ee.Algorithms.If(ee.Number(cost).gte(1),1,costttt1)
      // costttt1 = ee.Algorithms.If(ee.Number(cost).lte(-1),-1,costttt1)
      // costttt1 = ee.Algorithms.If(ee.Number(cost).lte(1).and(ee.Number(cost).gte(-1)),cost,costttt1)
      costttt1 = ee.Image(costttt1).where(costttt1.gt(1),1)
                        .where(costttt1.lt(-1),-1)
      var t = costttt1.acos()
      var O = (t.subtract(t.sin().multiply(cost))).multiply(temp3).divide(ee.Image(PI))
	    var kgeo = ee.Image(O.subtract(temp3).add((ee.Image(1).add(cosxip)).divide(ee.Image(2).multiply(temp1).multiply(temp2)))).rename('kgeo')  //Li_sparseR

	return [kvol, kgeo]}     //核函数   
function line_from_coords(coordinates, fromIndex, toIndex){
      return ee.Geometry.LineString(ee.List([
        coordinates.get(fromIndex),
        coordinates.get(toIndex)]));
  }
function apply_brdf_s2(img){
  
    var sunAz = img.metadata('MEAN_SOLAR_AZIMUTH_ANGLE','sunAz').multiply(PI).divide(180);
    var sZenith = img.metadata('MEAN_SOLAR_ZENITH_ANGLE','sunAz').multiply(PI).divide(180);
  
    var viewAz_blue = img.metadata('MEAN_INCIDENCE_AZIMUTH_ANGLE_B2','viewAz_blue').multiply(PI).divide(180);
    var viewZen_blue = img.metadata('MEAN_INCIDENCE_ZENITH_ANGLE_B2','viewZen_blue').multiply(PI).divide(180);
    
    var viewAz_green = img.metadata('MEAN_INCIDENCE_AZIMUTH_ANGLE_B3','viewAz_green').multiply(PI).divide(180);
    var viewZen_green = img.metadata('MEAN_INCIDENCE_ZENITH_ANGLE_B3','viewZen_green').multiply(PI).divide(180);
    
    var viewAz_red = img.metadata('MEAN_INCIDENCE_AZIMUTH_ANGLE_B4','viewAz_red').multiply(PI).divide(180);
    var viewZen_red = img.metadata('MEAN_INCIDENCE_ZENITH_ANGLE_B4','viewZen_red').multiply(PI).divide(180);
    
    var viewAz_nir = img.metadata('MEAN_INCIDENCE_AZIMUTH_ANGLE_B8','viewAz_nir').multiply(PI).divide(180);
    var viewZen_nir = img.metadata('MEAN_INCIDENCE_ZENITH_ANGLE_B8','viewZen_nir').multiply(PI).divide(180);
    
    var viewAz_swir = img.metadata('MEAN_INCIDENCE_AZIMUTH_ANGLE_B11','viewAz_swir').multiply(PI).divide(180);
    var viewZen_swir = img.metadata('MEAN_INCIDENCE_ZENITH_ANGLE_B11','viewZen_swir').multiply(PI).divide(180);
    
//***********************************************************使用各个波段的平均视场角作为c因子校正的输入，减少计算量*************************************
    var viewAz = (viewAz_blue.add(viewAz_green).add(viewAz_red).add(viewAz_nir).add(viewAz_swir)).divide(5)
    var viewZen = (viewZen_blue.add(viewZen_green).add(viewZen_red).add(viewZen_nir).add(viewZen_swir)).divide(5)    
//**************************************************************************************************************************************************    
    var kval = _kvol_s2(sunAz, sZenith, viewAz, viewZen);
    var kvol = kval[0].rename('kvol');
    var kgeo = kval[1].rename('kgeo');;
    
    var kval_up = _kvol_s2(sunAz,PI.divide(6),viewAz,0)
    var kvol_up = kval_up[0].rename('kvol_up');;
    var kgeo_up = kval_up[1].rename('kgeo_up');;

    // var kval_green = _kvol_s2(sunAz, sZenith, viewAz, viewZen);
    // var kvol_green = kval_green[0].rename('kvol_green');;
    // var kgeo_green = kval_green[1].rename('kgeo_green');;
    // var kval_up_green = _kvol_s2(sunAz,PI.divide(6),viewAz,0)
    // var kvol_up_green = kval_up_green[0].rename('kvol_up_green');;
    // var kgeo_up_green = kval_up_green[1].rename('kgeo_up_green');;
    
    // var kval_red = _kvol_s2(sunAz, sZenith, viewAz, viewZen);
    // var kvol_red = kval_red[0].rename('kvol_red');;
    // var kgeo_red = kval_red[1].rename('kgeo_red');;
    // var kval_up_red = _kvol_s2(sunAz,PI.divide(6),viewAz,0)
    // var kvol_up_red = kval_up_red[0].rename('kvol_up_red');;
    // var kgeo_up_red = kval_up_red[1].rename('kgeo_up_red');;
    
    // var kval_nir = _kvol_s2(sunAz, sZenith, viewAz, viewZen);
    // var kvol_nir = kval_nir[0].rename('kvol_nir');;
    // var kgeo_nir = kval_nir[1].rename('kgeo_nir');;
    // var kval_up_nir = _kvol_s2(sunAz,PI.divide(6),viewAz,0)
    // var kvol_up_nir = kval_up_nir[0].rename('kvol_up_nir');;
    // var kgeo_up_nir = kval_up_nir[1].rename('kgeo_up_nir');;
    
    // var kval_swir = _kvol_s2(sunAz, sZenith, viewAz, viewZen);
    // var kvol_swir = kval_swir[0].rename('kvol_swir');;
    // var kgeo_swir = kval_swir[1].rename('kgeo_swir');;
    // var kval_up_swir = _kvol_s2(sunAz,PI.divide(6),viewAz,0)
    // var kvol_up_swir = kval_up_swir[0].rename('kvol_up_swir');;
    // var kgeo_up_swir = kval_up_swir[1].rename('kgeo_up_swir');;

    // var kvol = kvol_blue.addBands([kvol_green,kvol_red,kvol_nir,kvol_swir])//ee.Dictionary(['kvol_blue',kvol_blue,'kvol_green',kvol_green,'kvol_red',kvol_red,'kvol_nir',kvol_nir,'kvol_swir',kvol_swir])
    // var kgeo = kgeo_blue.addBands([kgeo_green,kgeo_red,kgeo_nir,kgeo_swir])//ee.Dictionary(['kgeo_blue',kgeo_blue,'kgeo_green',kgeo_green,'kgeo_red',kgeo_red,'kgeo_nir',kgeo_nir,'kgeo_swir',kgeo_swir])
    // var kvol_up = kvol_up_blue.addBands([kvol_up_green,kvol_up_red,kvol_up_nir,kvol_up_swir])//ee.Dictionary(['kvol_up_blue',kvol_up_blue,'kvol_up_green',kvol_up_green,'kvol_up_red',kvol_up_red,'kvol_up_nir',kvol_up_nir,'kvol_up_swir',kvol_up_swir])
    // var kgeo_up = kgeo_up_blue.addBands([kgeo_up_green,kgeo_up_red,kgeo_up_nir,kgeo_up_swir])//ee.Dictionary(['kgeo_up_blue',kgeo_up_blue,'kgeo_up_green',kgeo_up_green,'kgeo_up_red',kgeo_up_red,'kgeo_up_nir',kgeo_up_nir,'kgeo_up_swir',kgeo_up_swir])
    
    var result = _apply_s2(img, kvol, kgeo,kvol_up,kgeo_up);
  
    return result;
}
function _apply_s2(image, kvol, kgeo,kvol_up,kgeo_up){
      var f_iso = 0;
      var f_geo = 0;
      var f_vol = 0;
      var kvol = ee.Image(kvol);
      var kgeo = ee.Image(kgeo);
      var kvol_up = ee.Image(kvol_up);
      var kgeo_up = ee.Image(kgeo_up);
      // print(kvol,kgeo,kvol_up,kgeo_up)
			var blue = _correct_band_s2(image, 'blue', kvol, kgeo, f_iso=0.0774, f_geo=0.0079, f_vol=0.0372,kvol_up,kgeo_up);
			var green = _correct_band_s2(image, 'green', kvol, kgeo, f_iso=0.1306, f_geo=0.0178, f_vol=0.0580,kvol_up,kgeo_up);
			var red = _correct_band_s2(image, 'red', kvol, kgeo, f_iso=0.1690, f_geo=0.0227, f_vol=0.0574,kvol_up,kgeo_up);
      var nir = _correct_band_s2(image, 'nir', kvol, kgeo, f_iso=0.3093, f_geo=0.0330, f_vol=0.1535,kvol_up,kgeo_up);
      var swir = _correct_band_s2(image, 'swir', kvol, kgeo, f_iso=0.3430, f_geo=0.0453, f_vol=0.1154,kvol_up,kgeo_up);   
     
			return image.select([]).addBands([blue, green, red, nir,swir]).set('blue_c',blue.get('c'))
			                                                              .set('green_c',green.get('c'))
			                                                              .set('red_c',red.get('c'))
			                                                              .set('nir_c',nir.get('c'))
			                                                              .set('swir_c',swir.get('c'));
}        //输入modis校正系数
function _correct_band_s2(image, band_name, kvol, kgeo, f_iso, f_geo, f_vol,kvol_up,kgeo_up){
			//"""fiso + fvol * kvol + fgeo * kgeo"""
			var iso = ee.Image(f_iso);
			var geo = ee.Image(f_geo);
			var vol = ee.Image(f_vol);
			var pred = vol.multiply(kvol).add(geo.multiply(kgeo)).add(iso).rename(['pred']);
			var pred_up = vol.multiply(kvol_up).add(geo.multiply(kgeo_up)).add(iso).rename(['pred_up']);
			var cfac = pred_up.divide(pred).rename(['cfac']);             //计算c因子
			var c = cfac.reduceRegion({
                  reducer: ee.Reducer.first(),
                  geometry:point,
                  scale: scale,
                  maxPixels: 1e13
                });
			var corr = image.select(band_name).multiply(cfac).rename([band_name]).set('c',ee.Number(c.get('cfac')));
			return corr;
  }       //
function _kvol_s2(sAzimuth, sZenith, vAzimuth, vZenith){
			//"""Calculate kvol kernel.
			//From Lucht et al. 2000
			//Phase angle = cos(solar zenith) cos(view zenith) + sin(solar zenith) sin(view zenith) cos(relative azimuth)"""
			sAzimuth = ee.Image(sAzimuth)
			sZenith = ee.Image(sZenith)
			vAzimuth = ee.Image(vAzimuth)
			vZenith = ee.Image(vZenith)
			var rAzimuth = sAzimuth.subtract(vAzimuth).rename(['relAz']);
			var pa1 = vZenith.cos().multiply(sZenith.cos());
			var pa2 = vZenith.sin().multiply(sZenith.sin()).multiply(rAzimuth.cos());
			var phase_angle1 = pa1.add(pa2);
			var phase_angle = phase_angle1.acos();
			var p1 = ee.Image(PI.divide(2)).subtract(phase_angle);
			var p2 = p1.multiply(phase_angle1);
			var p3 = p2.add(phase_angle.sin());
			var p4 = sZenith.cos().add(vZenith.cos());
			var p5 = ee.Image(PI.divide(4));

			var kvol = p3.divide(p4).subtract(p5).rename(['kvol']);     //Ross_thick


      var t1 = sZenith.tan()
	    var ttt1 = t1;
	   // ttt1 = ee.Algorithms.If(ee.Number(t1).lte(0),0,ttt1)
	   // ttt1 = ee.Algorithms.If(ee.Number(t1).gt(0),t1,ttt1)
	    var ttt1 = ee.Image(ttt1).where(ttt1.lt(0),0)
	    var theta_ip = ttt1.atan()
      var t2 = vZenith.tan()
	    var ttt2 = t2;
	   // ttt2 = ee.Algorithms.If(ee.Number(t2).lt(0),0,ttt2)
	   // ttt2 = ee.Algorithms.If(ee.Number(t2).gte(0),t2,ttt2)
	    ttt2 = ee.Image(ttt2).where(ttt2.lt(0),0)
      var theta_vp = ttt2.atan()
	    var temp1 = theta_ip.cos()
	    var temp2 = theta_vp.cos()
	    var cosxip = temp1.multiply(temp2).add(theta_ip.sin().multiply(theta_vp.sin()).multiply(rAzimuth.cos()))
	    var D1 = t1.multiply(t1).add(t2.multiply(t2)).subtract(t1.multiply(t2).multiply(rAzimuth.cos().multiply(ee.Image(2))))
	   // D1 = ee.Algorithms.If(ee.Number(D1).lt(0),0,D1)
	    D1 = ee.Image(D1).where(D1.lt(0),0)
      var D = D1.sqrt()
      var cost1 = t1.multiply(t2).multiply(rAzimuth.sin())
      var cost2 = D1.add(cost1.multiply(cost1))
      var temp3 = ee.Image(1).divide(temp1).add(ee.Image(1).divide(temp2))
      var cost = (cost2.sqrt().divide(temp3)).multiply(2)
	    var costttt1 = cost;
      // costttt1 = ee.Algorithms.If(ee.Number(cost).gte(1),1,costttt1)
      // costttt1 = ee.Algorithms.If(ee.Number(cost).lte(-1),-1,costttt1)
      // costttt1 = ee.Algorithms.If(ee.Number(cost).lte(1).and(ee.Number(cost).gte(-1)),cost,costttt1)
      costttt1 = ee.Image(costttt1).where(costttt1.gt(1),1)
                        .where(costttt1.lt(-1),-1)
      var t = costttt1.acos()
      var O = (t.subtract(t.sin().multiply(cost))).multiply(temp3).divide(ee.Image(PI))
	    var kgeo = ee.Image(O.subtract(temp3).add((ee.Image(1).add(cosxip)).divide(ee.Image(2).multiply(temp1).multiply(temp2)))).rename('kgeo')  //Li_sparseR

	return [kvol, kgeo]}     //核函数   
function calculate_IC(img){
 
// get image metadata about solar position
var sZenith = ee.Image.constant(ee.Number(img.get('MEAN_SOLAR_ZENITH_ANGLE'))).multiply(3.14159265359).divide(180).clip(ROI.buffer(1000));
var sunAz = ee.Image.constant(ee.Number(img.get('MEAN_SOLAR_AZIMUTH_ANGLE')).multiply(3.14159265359).divide(180)).clip(ROI.buffer(1000));
// Creat terrain layers
var slp = ee.Terrain.slope(dem).clip(ROI.buffer(1000));
var slp_rad = ee.Terrain.slope(dem).multiply(PI).divide(180).clip(ROI.buffer(1000));
var asp_rad = ee.Terrain.aspect(dem).multiply(PI).divide(180).clip(ROI.buffer(1000));
 
// Calculate the Illumination Condition (IC)
// slope part of the illumination condition
var cosZ = sZenith.cos();
var cosS = slp_rad.cos();
var slope_illumination = cosS.expression("cosZ * cosS",
                                        {'cosZ': cosZ,
                                        'cosS': cosS.select('slope')});
// aspect part of the illumination condition
var sinZ = sZenith.sin();
var sinS = slp_rad.sin();
var cosAziDiff = (sunAz.subtract(asp_rad)).cos();
var aspect_illumination = sinZ.expression("sinZ * sinS * cosAziDiff",
                                        {'sinZ': sinZ,
                                          'sinS': sinS,
                                          'cosAziDiff': cosAziDiff});
// full illumination condition (IC)
var ic = slope_illumination.add(aspect_illumination);
 
// Add IC to original image
var img_plus_ic = ee.Image(img.addBands(ic.rename('IC')).addBands(cosZ.rename('cosZ')).addBands(cosS.rename('cosS')).addBands(slp.rename('slope')));
return img_plus_ic;
}	
function topo_SCSc(img){
  
var img_plus_ic = img;
var mask1 = img_plus_ic.select('nir').gt(-0.1);
var mask2 = img_plus_ic.select('slope').gte(5)
.and(img_plus_ic.select('IC').gte(0))
.and(img_plus_ic.select('nir').gt(-0.1))
.and(esa_mask);

var img_plus_ic_mask2 = ee.Image(img_plus_ic.updateMask(mask2));
 
var bandList = ['blue','green','red','nir','swir']; // Specify Bands to topographically correct
var compositeBands = img.bandNames();
var nonCorrectBands = img.select(compositeBands.removeAll(bandList));//不校正的波段 

function apply_SCSccorr(bandList){
var method = 'SCSc';
var out = img_plus_ic_mask2.select('IC', bandList).reduceRegion({
reducer: ee.Reducer.linearFit(), // Compute coefficients: a(slope), b(offset), c(b/a)
geometry: ROI.buffer(-150), // trim off the outer edges of the image for linear relationship
scale: scale,
maxPixels: 1e13
});

function out_(){
  var out_a = ee.Number(out.get('scale'));
  var out_b = ee.Number(out.get('offset'));
  var out_c = out_b.divide(out_a);//ee.Number(out.get('offset')).divide(ee.Number(out.get('scale')));

  //apply the SCSc correction
  var SCSc_output = img_plus_ic_mask2.expression("((image * (cosB * cosZ + cvalue)) / (ic + cvalue))", {
                                                  'image': img_plus_ic_mask2.select(bandList),
                                                  'ic': img_plus_ic_mask2.select('IC'),
                                                  'cosB': img_plus_ic_mask2.select('cosS'),
                                                  'cosZ': img_plus_ic_mask2.select('cosZ'),
                                                  'cvalue': out_c
                                                  });
 
  return ee.Image(SCSc_output).set('out_c',out_c);
  
}

var topo = ee.Algorithms.If(out.get('scale'),out_(),img_plus_ic_mask2.select(bandList))

return ee.Image(topo).copyProperties(img_plus_ic, img_plus_ic.propertyNames());

}
var img_SCSccorr = ee.Image(bandList.map(apply_SCSccorr)).addBands(img_plus_ic.select('IC'));
var bandList_IC = ee.List([bandList, 'IC']).flatten();
return img_SCSccorr.unmask(img_plus_ic.select(bandList_IC))
.addBands(nonCorrectBands)
.addBands(mask1.rename('initMask'))
.addBands(mask2.rename('corrMask'));
}	
function sensor_tran(img){
  var blue = img.select('blue');
  var green = img.select('green');
  var red = img.select('red');
  var nir = img.select('nir');
  var swir = img.select('swir');
   
  blue = blue.multiply(0.9584).add(0.0034);
  green = green.multiply(0.9162).add(0.0028);
  red = red.multiply(1.0058).add(0.0001);
  nir = nir.multiply(0.9796).add(0.0069);
  swir = swir.multiply(1.0136).add(0.0073);
  return img.select().addBands([blue,green,red,nir,swir])
}
function get_vi(img){
  var blue = img.select('blue');
  var green = img.select('green');
  var red = img.select('red');
  var nir = img.select('nir');
  var swir = img.select('swir');
   
  var ndvi = img.normalizedDifference(['nir','red']).rename(['NDVI']);
  var evi = (ee.Image(2.5).multiply(nir.subtract(red))).divide(nir.add(red.multiply(6)).subtract(blue.multiply(7.5)).add(1)).rename('EVI');
  var NIRv = ndvi.subtract(0.08).multiply(nir).rename(['NIRv']);
  var ndwi = img.normalizedDifference(['green','nir']).rename(['NDWI']);
  var ndfsi = img.normalizedDifference(['nir','swir']).rename(['NDFSI']);  
  var kNDVI = ndvi.pow(2).tanh().rename(['kNDVI']);  
  var vi = img.select().addBands([ndvi,evi,NIRv,kNDVI])
  var mask = ee.Image(ndvi.subtract(ndwi)).gt(0).and(ndvi.gt(0)).and(ndvi.lt(1)).and(ndfsi.lt(0.5))
  return vi.updateMask(mask)
            .where(vi.lt(0),0) // force low values to threshMin 把小于最小值的替换为最小值
            .where(vi.gt(0.9),0.9) // 防止异常值
            // .set('system:time_start', img.get('system:time_start'))
            // .set('doy',ee.Number(img.date().getRelative('day','year')).add(1))
            // //.set('id',img.get('id'))
}
function sg_smooth(col,bandname){
  var col = col.select(bandname);
  var sg_col = oeel.ImageCollection.SavatskyGolayFilter(col,                     //SG滤波函数
      ee.Filter.maxDifference(diff, 'system:time_start', null, 'system:time_start'),//@ collection：你准备平滑的影像数据集
      function(infromedImage,estimationImage){
        return ee.Image.constant(ee.Number(infromedImage.get('system:time_start'))//@ filter：滑动窗口大小
          .subtract(ee.Number(estimationImage.get('system:time_start'))));},//@ distanceFunction：距离函数
      4,[bandname]).sort('system:time_start');//@ degree：拟合多项式的次数       //@ bandOfInterest：你准备平滑的影像数据波段
        
  sg_col = sg_col.map(function(img){
    var smooth = img.select(ee.String('d_0_').cat(bandname)).rename(ee.String('sg_').cat(bandname));       //对平滑后的波段进行重命名
    // var daoshu = img.select(ee.String('d_1_').cat(bandname)).rename(ee.String('f1_').cat(bandname)).multiply(2000000000);
    return img.select(bandname).addBands([smooth])                                     //把重命名的新波段添加到影像中
  })

  return sg_col
}
function cubicInterpolation(collection,step){                   //step=1，生成每一天的影像，为2则是生成每2天的影像

var listDekads = ee.List.sequence(1, collection.size().subtract(3), 1);  // 为何减3而不是减2，因为生成的列表包含最后一个

var colInterp = listDekads.map(function(ii){  //由第二张影像集合开始到影像去除最后三张结束，遍历影像集合

  var ii = ee.Number(ii);
  //取出相邻的4张影像
    var p0 = ee.Image(collection.toList(1000).get(ee.Number(ii).subtract(1)));
    var p1 = ee.Image(collection.toList(1000).get(ii));
    var p2 = ee.Image(collection.toList(1000).get(ee.Number(ii).add(1)));
    var p3 = ee.Image(collection.toList(1000).get(ee.Number(ii).add(2)));
  //求取相邻影像的时间差异，单位为天
    var diff01 = ee.Date(p1.get('system:time_start')).difference(ee.Date(p0.get('system:time_start')), 'day');
    var diff12 = ee.Date(p2.get('system:time_start')).difference(ee.Date(p1.get('system:time_start')), 'day');
    var diff23 = ee.Date(p3.get('system:time_start')).difference(ee.Date(p2.get('system:time_start')), 'day');
    
    var diff01nor = diff01.divide(diff12);   //影像相隔的时间的比例
    var diff12nor = diff12.divide(diff12);
    var diff23nor = diff23.divide(diff12);
    //
    var f0 = p1;
    var f1 = p2;
    var f0p = (p2.subtract(p0)).divide(diff01nor.add(diff12nor)); //两张影像值的差除以两张影像相隔的时间
    var f1p = (p3.subtract(p1)).divide(diff12nor.add(diff23nor));
    //ax^3+bx^2+cx+d    三次样条函数一个方程有4个未知数
    var a = (f0.multiply(2)).subtract(f1.multiply(2)).add(f0p).add(f1p);
    var b = (f0.multiply(-3)).add(f1.multiply(3)).subtract(f0p.multiply(2)).subtract(f1p);
    var c = f0p;
    var d = f0;   //解出四个系数的值，根据本张影像，就可以估计出本张影像与下一张影像相隔时间内任一天的影像
    
  ///////////// 
  var xValues = ee.List.sequence(0,diff12.subtract(1),step); ///本张影像与下一张影像减去一天的时间的差的时间，单位为天
  //  起始：本张影像的时间，结束：下一张影像的时间，间隔为1天
  var xDates = ee.List.sequence(p1.get('system:time_start'),p2.get('system:time_start'),86400000);
  //print(xDates)  
  
  var interp = (xValues.map(function(x){    //循环  两张影像差的天数减1天  次
    var im = ee.Image(ee.Number(x).divide(diff12));  //小于1 ，假设差的天数为4，则，im分别等于1/4,2/4,3/4
    return (im.pow(3)).multiply(a).add((im.pow(2)).multiply(b)).add(im.multiply(c)).add(d)  //三次函数
        .set('system:time_start',ee.Number(xDates.get(x)))   ///设置时间，估计没有影像的时间的影像
        .set('doy',ee.Number(ee.Date(xDates.get(x)).getRelative("day", "year")));
    }));
    
   return interp //返回一个影像列表 list
  })
  
  var colInterp = ee.ImageCollection(colInterp.flatten());
  
  return colInterp  //返回一个影像集合   imageCollection
}
function extract_pheno_thresh(imgcol,thresh,bandname){
  var imgcol = ee.ImageCollection(imgcol).select(bandname)
  //get the amplitude of time series
  var min_vi = imgcol.min();
  var max_vi = imgcol.max();
  var amplitude = max_vi.subtract(min_vi)
  //compute thresh
  var threshold = amplitude.multiply(thresh).add(min_vi).rename(ee.String('thresh_').cat(bandname));
  // print('thresh is',threshold.reduceRegion(ee.Reducer.first(), point, scale))
  imgcol = imgcol.map(function(img){  
  return img.addBands(img.metadata('system:time_start','date'))/////metadata的两个参数，一个是要提取的属性名，一个是新生成的图像中波段的名称
  })
  //mask values below the threshold
  var above_thresh = imgcol.filter(ee.Filter.dayOfYear(50,330)).map(function(img){
    var mask = img.select(bandname).gte(threshold);
    return img.updateMask(mask).select('date')
  })
  var SoS = above_thresh.reduce(ee.Reducer.firstNonNull()).select('date_first').rename(ee.String('thresh_SoS_').cat(bandname))//firstNonNull，选择第一个非null的值，这个值所在图像的日期就是sos
  var EoS = above_thresh.reduce(ee.Reducer.lastNonNull()).select('date_last').rename(ee.String('thresh_EoS_').cat(bandname))
  
  var SoS_doy = SoS.subtract(init).divide(86400000).toInt(); // convert to doy  将毫秒数转换为天
  var EoS_doy = EoS.subtract(init).divide(86400000).toInt(); // convert to doy  将毫秒数转换为天
  
  var phenology = SoS_doy.addBands([EoS_doy,threshold]);
  return phenology.clip(ROI)
}
function mean_smooth(img){
   var image = ee.ImageCollection(img)
   var beforeImages = ee.ImageCollection.fromImages(ee.List(image.get('before')))
   var afterImages = ee.ImageCollection.fromImages(ee.List(image.get('after')))
   var mean = beforeImages.merge(image).merge(afterImages)
   var img_pro = img.propertyNames()
   return mean.copyProperties(img, img_pro)           
   
}
function sg(inputDictionary) {

  var saveAllJoin = ee.Join.saveAll({
    matchesKey: 'neighbours',
    measureKey: 'distanceError'
  });

  var expendSelect = inputDictionary.collection.first().select(inputDictionary.bandOfInterest).bandNames();//EVI

  return ee.ImageCollection(saveAllJoin.apply(inputDictionary.collection.select(expendSelect), inputDictionary.collection.select(expendSelect), inputDictionary.filter)).map(  //过滤一定时间差范围的影像
    function(im) {
      var imCol = ee.ImageCollection(ee.List(im.get('neighbours')));   //一定时间差范围的影像集合
      imCol = imCol.map(function(Nim) {
        var delta = inputDictionary.distanceFunction(Nim, im);//计算时间差影像集内影像与此影像的时间差
       
        var deltaList = [];//时间差的次数集合
        for (var i = 0; i < inputDictionary.degree; i++) {
          deltaList.push(delta.pow(i))
        }
        delta = ee.ImageCollection(deltaList).toBands().updateMask(Nim.select([0]).mask());
        return Nim.addBands(delta);
      });    //imcol是一个含有波段值，时间差，时间差的2次，3次等次数的影像

      var matrix = imCol.toArray();//0轴是影像轴，1轴是波段轴
      var numberOfNeihbours = matrix.arrayLength(0).rename('NoN');//邻域影像集的数量
      matrix = matrix.updateMask(numberOfNeihbours.gte(inputDictionary.degree + 2));//数量太少的掩膜掉，因为无法求出矩阵的唯一解
      var dT = matrix.arraySlice(1, -inputDictionary.degree);     //获取几个影像时间差的波段
      var boI = matrix.arraySlice(1, 0, -inputDictionary.degree);  //获取其余波段
      var coef = dT.matrixSolve(boI);
      // var extrapolate = dT.arraySlice(1, 1, 2)
      //   .arrayReduce(ee.Reducer.minMax(), [0], 1)
      //   .multiply(ee.Array([[-1, 1]])).lt(0).arrayReduce(ee.Reducer.max(), [1], 0).arrayGet([0, 0])
      //   .rename('extrapolate_flag');

      var generated = coef.arrayFlatten([Array.apply(0, Array(inputDictionary.degree)).map(function(_, i) {
        return i;
      }).map(function(i) {
        return 'd_' + i
      }), expendSelect])//.addBands([extrapolate, numberOfNeihbours]);

      // if (isFeatureCollection)
      //   return generated.copyProperties(im, im.propertyNames());
      // else
        return im.addBands(generated);
    });
}
function move_window(col,dif){
      var saveAllJoin = ee.Join.saveAll({
      matchesKey: 'neighbours',
      measureKey: 'distanceError'
    });
    var dif = ee.Number(dif)
    var diff = dif.multiply(1000*3600*24)
    var filter = ee.Filter.maxDifference(diff, 'system:time_start', null, 'system:time_start')
    return ee.ImageCollection(saveAllJoin.apply(col, col, filter)).map(
      function(im){
        var imCol=ee.ImageCollection(ee.List(im.get('neighbours')));
      
          var finalim=imCol.reduce(ee.Reducer.mean());
          return finalim.copyProperties(im,im.propertyNames().remove('neighbours').remove("system:footprint"))
    });
}
function exportImage_ToAs(image, region, fileName) {  
  Export.image.toAsset({  
      image: image,  //设置要输出的影像
      description: "Multi-"+fileName,  // 设置下载任务tasks的名称
      // fileNamePrefix: fileName,  //设置下载影像的名称
      // folder: "SENTINEL-2",  //设置下载影像在Drive中存储的文件夹名称（可不设置）
      assetId:'projects/ee-phenology-last/assets/us-phenology/'+fileName,
      scale: scale, //空间分辨率，单位：米
      region: region,  //要下载影像的范围
      maxPixels: 1e13, //单幅影像输出的最大像元数
      // fileFormat:"GeoTIFF", //设置影像导出格式，注意GeoTIFF格式需要所有波段存储类型一致（如不能同时存Int16和Int32）
      crs: "EPSG:4326"  //投影信息，一般是采用默认方式，通常可以设置为EPSG:4326
      
  });  
}     //导出结果

















